<script setup lang="ts" generic="PayloadType extends object">
import { usePointer, useEventListener } from "@vueuse/core";
import {
  ref,
  toRaw,
  onMounted,
  watch,
  computed,
  nextTick,
  Ref,
  onUnmounted,
  provide,
  inject,
} from "vue";
import { useMovingItem } from "./useMovingItem.js";
import { useArrangeableLists } from "./useArrangeableLists.js";
import PointerElement from "./PointerElement.vue";
import {
  type ArrangeableOptions,
  TargetIdentifier,
  Target,
  MovingItem,
} from "./types.js";

// N.b. moving this type to types.ts will cause a compiler error.
export type ArrangeableProps<T> = {
  tag?: string;
  listItemTag?: string;
  options?: ArrangeableOptions;
  list: T[];
  // Can we use an inferred key here, as in keyof PayloadType? It throws weird errors below.
  listKey?: string;
  identifier?: TargetIdentifier;
  meta?: unknown;
  group?: TargetIdentifier;
  targets?: TargetIdentifier | Array<TargetIdentifier>;
};

type KeyItem = {
  payload: PayloadType;
  // TODO: put the correct type here
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  key: any;
};

const props = defineProps<ArrangeableProps<PayloadType>>();

const defaultIdentifier = Symbol();
const identifier = computed(() => props.identifier ?? defaultIdentifier);

const defaultOptions: ArrangeableOptions = {
  defaultItemClass: "",
  pickedItemClass: "arrangeable-list__invisible",
  hoveredOverListClass: "",
  listTransition: {
    moveClass: "arrangeable-list__transition-all",
    leaveActiveClass: "arrangeable-list__absolute",
  },
  hoverTransitionClass: "arrangeable-list__transition-all-but-location",
  hoverClass: "",
  homingEffect: true,
  handle: false,
  liftDelay: 0,
};
const options = computed<ArrangeableOptions>(() => {
  return { ...defaultOptions, ...props.options };
});
const homingEffectClass = computed<string>(() => {
  if (
    typeof options.value.homingEffect === "boolean" &&
    options.value.homingEffect
  )
    return "arrangeable-list__homing-effect";
  return options.value.homingEffect || "";
});

const pointer = usePointer();
const { movingItem, isMoving, movingItemCanTarget } =
  useMovingItem<PayloadType>();
const { addList, removeList, targetedList } = useArrangeableLists();

const hoverElement = ref<HTMLElement>();
const listElement = ref<InstanceType<typeof PointerElement>>();
let offsetX: number = 0;
let offsetY: number = 0;
let originItemBoundingBox: DOMRect | undefined;

// https://github.com/vuejs/core/issues/2136#issuecomment-908269949
const keyItemsList = ref<KeyItem[]>([]) as Ref<KeyItem[]>;
const arrangedItems = computed(
  () => keyItemsList.value.map(({ payload }) => payload) || [],
);

function populateList(listData: PayloadType[]) {
  const newList: KeyItem[] = [];
  // Make sure to preserve the keys associated with the objects, whether autogenerated or supplied:
  listData.forEach((item: PayloadType) => {
    const keyItem = props.listKey
      ? keyItemsList.value.find(
          ({ key }) => key === item[props.listKey as keyof PayloadType],
        )
      : keyItemsList.value.find(({ payload }) => item === payload);
    if (keyItem) newList.push({ ...keyItem, payload: item });
    else
      newList.push({
        key:
          props.listKey && Object.keys(item).includes(props.listKey)
            ? item[props.listKey as keyof PayloadType]
            : Symbol(),
        payload: item,
      });
  });
  keyItemsList.value = newList;
}

watch(() => props.list, populateList, { deep: true });
watch(
  () => movingItem.value?.destination,
  (newDestination, previousDestination) => {
    if (
      newDestination?.identifier !== identifier.value &&
      previousDestination?.identifier === identifier.value
    ) {
      keyItemsList.value = keyItemsList.value.filter(
        ({ payload }) => payload !== movingItem.value?.payload,
      );
    }
  },
);

const emit = defineEmits<{
  (e: "liftItem", item: MovingItem<PayloadType>): void;
  (e: "dropItem", item: MovingItem<PayloadType>): void;
}>();

/**
 * triggered when the mouse cursor enters a list item while dragging something.
 * @param index: index of the item hovered over.
 */
const hoverOverItem = (index: number) => {
  if (
    !movingItem.value ||
    movingItem.value?.destination?.identifier !== identifier.value ||
    isMoving(arrangedItems.value[index])
  ) {
    return;
  }

  // if the dragging item does not appear in the list, add it
  if (
    keyItemsList.value.findIndex(
      ({ payload }) => payload === movingItem.value?.payload,
    ) === -1
  ) {
    keyItemsList.value.splice(index, 0, {
      payload: movingItem.value.payload,
      key: movingItem.value.key,
    });
  }
  // else move it
  else {
    const moverIndex = keyItemsList.value.findIndex(
      ({ payload }) => payload === movingItem.value?.payload,
    );
    keyItemsList.value =
      moverIndex < index
        ? [
            ...keyItemsList.value.slice(0, moverIndex),
            ...keyItemsList.value.slice(moverIndex + 1, index + 1),
            keyItemsList.value[moverIndex],
            ...keyItemsList.value.slice(index + 1),
          ]
        : [
            ...keyItemsList.value.slice(0, index),
            keyItemsList.value[moverIndex],
            ...keyItemsList.value.slice(index, moverIndex),
            ...keyItemsList.value.slice(moverIndex + 1),
          ];
  }
  movingItem.value.destination.index = index;
  movingItem.value.destination.listItems = arrangedItems.value;
};

/**
 * triggered when the mouse cursor leaves this list while dragging something that targets this list.
 */
const leaveList = () => {
  if (movingItem.value === undefined) return;
  // N.b. if the v-for list inside the transitiongroup has a ref with a ref() constant in the setup function,
  // leaving the list will go clunky. https://github.com/vuejs/core/issues/8173
  const itemIndex = arrangedItems.value.indexOf(movingItem.value.payload);
  if (itemIndex >= 0) {
    keyItemsList.value.splice(itemIndex, 1);
  }
  if (movingItem.value.destination?.identifier === identifier.value) {
    movingItem.value.destination = movingItem.value.origin;
  }
};

/**
 * triggered when the mouse cursor enters this list while dragging something that targets this list.
 */
const enterList = () => {
  if (!movingItem.value) return;

  if (arrangedItems.value.length === 0)
    keyItemsList.value = [
      { payload: movingItem.value.payload, key: movingItem.value.key },
    ];
  movingItem.value.destination = {
    identifier: identifier.value,
    type: "list",
    listItems: arrangedItems.value,
    meta: props.meta,
  };
};

const applyClasses = (element: HTMLElement | undefined, classes: string) => {
  if (!element) return;
  classes.split(" ").forEach((className) => {
    if (className) element.classList.add(className);
  });
};

const removeClasses = (element: HTMLElement | undefined, classes: string) => {
  if (!element) return;
  classes.split(" ").forEach((className) => {
    if (className) element.classList.remove(className);
  });
};

const handleName = computed(() => {
  return typeof options.value.handle === "string"
    ? options.value.handle
    : "handle";
});

const liftItem = (currentTarget: HTMLElement, { key, payload }: KeyItem) => {
  originItemBoundingBox = currentTarget.getBoundingClientRect();

  offsetX = pointer.x.value - originItemBoundingBox.x;
  offsetY = pointer.y.value - originItemBoundingBox.y;
  const originIndex = arrangedItems.value.indexOf(payload);
  const origin: Target<PayloadType> = {
    identifier: identifier.value,
    type: "list",
    listItems: arrangedItems.value,
    index: originIndex,
  };
  movingItem.value = {
    payload,
    hoverElement,
    origin: origin,
    destination: { ...origin, meta: props.meta },
    dropTargets: [props.targets ?? props.group ?? identifier.value].flat(),
    key,
  };

  nextTick(() => {
    setHomingArea();
    applyClasses(hoverElement.value, options.value.hoverTransitionClass || "");
    applyClasses(hoverElement.value, options.value.hoverClass || "");
    useEventListener(
      hoverElement.value,
      "transitionend",
      () => {
        removeClasses(
          hoverElement.value,
          options.value.hoverTransitionClass || "",
        );
      },
      { once: true },
    );
  });

  if (movingItem.value) {
    emit("liftItem", toRaw(movingItem.value));
  }
};

let pickupTimer: ReturnType<typeof setTimeout>;
const pickupItem = (event: PointerEvent, item: KeyItem) => {
  const { target, currentTarget } = event;
  if (
    options.value.handle &&
    (target as HTMLElement)?.getAttribute("name") !== handleName.value
  )
    return;

  pickupTimer = setTimeout(() => {
    liftItem(currentTarget as HTMLElement, item);
  }, options.value.liftDelay);
};

const cancelPickup = () => {
  clearTimeout(pickupTimer);
};

/**
 * Set coordinates of the snap-target element as CSS-variables to use in dynamic classes
 **/
const setHomingArea = () => {
  homingArea.value =
    document
      .getElementById("arrangeable-list-target-element")
      ?.getBoundingClientRect() ?? originItemBoundingBox;
};
const homingArea = ref<DOMRect | undefined>();
/**
 * dropItem happens when an element from this ArrangedList is dropped somewhere.
 * This is NOT triggered when an element from another list is dropped onto this one.
 */
const dropItem = () => {
  if (
    movingItem.value === undefined ||
    movingItem.value.origin.identifier !== identifier.value
  )
    return;

  let transitionDropEffect = false;

  nextTick(() => {
    setHomingArea();
    applyClasses(hoverElement.value, options.value.hoverTransitionClass || "");
    if (homingEffectClass.value)
      applyClasses(hoverElement.value, homingEffectClass.value);
    // check if the element has a transition effect
    let transitionProperty = getComputedStyle(
      hoverElement.value as HTMLElement,
    ).transitionProperty;
    let transitionDuration = getComputedStyle(
      hoverElement.value as HTMLElement,
    ).transitionDuration;
    if (
      transitionProperty !== "none" &&
      transitionDuration
        .split(", ")
        .some((duration) => parseFloat(duration) > 0)
    ) {
      transitionDropEffect = true;
    }
    removeClasses(hoverElement.value, options.value.hoverClass || "");
    if (transitionDropEffect) {
      useEventListener(
        hoverElement.value,
        "transitionend",
        () => (movingItem.value = undefined),
        { once: true },
      );
    } else {
      movingItem.value = undefined;
    }
  });
  emit("dropItem", toRaw(movingItem.value));

  // repopulation is needed in case the drop event did not trigger a props change
  // otherwise the dropped item disappears.
  populateList(props.list);
};
useEventListener(document, "pointerup", () => {
  cancelPickup();
  dropItem();
});

const beforeKey = Symbol();
const afterKey = Symbol();

// keep track of nested relationships
const stackLevel = inject<number>("arrangeableListStackLevel", 0);
provide<number>("arrangeableListStackLevel", stackLevel + 1);

const candidateHoversOver = computed<boolean>(
  () => targetedList.value === identifier.value,
);

onMounted(() => {
  addList(
    identifier.value,
    props.group,
    stackLevel,
    computed(() => listElement.value?.isAbove ?? false),
    enterList,
    leaveList,
  );
  populateList(props.list);
  document.body.style.touchAction = "none";
});

onUnmounted(() => {
  removeList(identifier.value);
  document.body.style.touchAction = "";
});
</script>

<template>
  <PointerElement
    name="ArrangeableList"
    ref="listElement"
    :tag="tag ?? 'ul'"
    :class="candidateHoversOver ? options.hoveredOverListClass : ''"
  >
    <TransitionGroup
      v-bind="
        !movingItem || movingItemCanTarget([identifier, group])
          ? options.listTransition
          : {} // fix for vue bug https://github.com/vuejs/core/issues/5385
      "
    >
      <component :is="listItemTag ?? 'li'" :key="beforeKey">
        <slot name="before" :arrangedItems="arrangedItems" />
      </component>
      <PointerElement
        v-for="(item, index) in keyItemsList || []"
        :key="item.key"
        :tag="listItemTag ?? 'li'"
        :id="
          isMoving(item.payload) ? 'arrangeable-list-target-element' : undefined
        "
        :class="
          isMoving(item.payload)
            ? options.pickedItemClass
            : options.defaultItemClass
        "
        @touchstart.left.prevent="pickupItem($event, item)"
        @pointerdown.left.stop="pickupItem($event, item)"
        @pointer-enter="hoverOverItem(index)"
      >
        <slot
          :item="item.payload as PayloadType"
          :arrangedItems="arrangedItems"
        />
      </PointerElement>
      <PointerElement
        :key="afterKey"
        :tag="listItemTag ?? 'li'"
        @pointer-enter="hoverOverItem(keyItemsList.length)"
      >
        <slot name="after" :arrangedItems="arrangedItems" />
      </PointerElement>
    </TransitionGroup>
    <Transition
      tag="div"
      ref="hoverElement"
      v-if="movingItem && movingItem.origin.identifier === identifier"
      :style="{
        left: pointer.x.value - offsetX + 'px',
        top: pointer.y.value - offsetY + 'px',
        width: originItemBoundingBox?.width + 'px',
        height: originItemBoundingBox?.height + 'px',
        '--landingzone-top': homingArea?.top + 'px',
        '--landingzone-left': homingArea?.left + 'px',
        '--landingzone-right': homingArea?.right + 'px',
        '--landingzone-bottom': homingArea?.bottom + 'px',
        '--landingzone-width': homingArea?.width + 'px',
        '--landingzone-height': homingArea?.height + 'px',
      }"
      style="z-index: 100000000; position: absolute"
    >
      <slot :item="movingItem.payload" />
    </Transition>
  </PointerElement>
</template>

<style>
/* well-known tailwind classes, to be used as sensible defaults */
.arrangeable-list__transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.arrangeable-list__transition-all-but-location {
  transition-property: opacity, transform, box-shadow, background-color,
    border-color, color, fill, stroke, padding, margin;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.arrangeable-list__absolute {
  position: absolute;
}
.arrangeable-list__invisible {
  visibility: hidden;
}
.arrangeable-list__homing-effect {
  transition-property: all;
  top: var(--landingzone-top) !important;
  left: var(--landingzone-left) !important;
}
</style>
