<script setup lang="ts" generic="PayloadType extends object">
import { usePointer, useEventListener } from "@vueuse/core";
import {
  ref,
  toRaw,
  onMounted,
  watch,
  computed,
  nextTick,
  Ref,
  TransitionProps,
  TransitionGroupProps,
} from "vue";
import { useMovingItem } from "./useMovingItem.js";
import PointerElement from "./PointerElement.vue";
import { DropTarget, DropTargetIdentifier, type MovingItem } from "./types.js";

export type ArrangeableOptions = {
  hoverClass?: string;
  dropClass?: string;
  pickedItemClass?: string;
  unpickedItemClass?: string;
  listTransition?: TransitionGroupProps;
  hoverTransition?: TransitionProps;
  handle?: boolean | string;
};

export type ArrangeableProps<T> = {
  options?: ArrangeableOptions;
  list: T[];
  // Can we use an inferred key here, as in keyof PayloadType? It throws weird errors below.
  listKey?: string;
  identifier?: DropTargetIdentifier;
  meta?: any;
  group?: DropTargetIdentifier;
  targets?: DropTargetIdentifier | Array<DropTargetIdentifier>;
};

const props = withDefaults(defineProps<ArrangeableProps<PayloadType>>(), {
  identifier: Symbol(),
  group: undefined,
  targets: undefined,
  meta: undefined,
  options: () => ({
    hoverClass: "",
    dropClass: "",
    hoverTransitionClass: "",
    hoverTransition: {},
    pickedItemClass: "",
    unpickedItemClass: "",
    listTransition: {},
  }),
});

type KeyItem = {
  payload: PayloadType;
  key: any;
};

const { movingItem, isMoving } = useMovingItem<PayloadType>();
const hoverElement = ref<HTMLElement>();
// https://github.com/vuejs/core/issues/2136#issuecomment-908269949
const keyItemsList = ref<KeyItem[]>([]) as Ref<KeyItem[]>;
const arrangedItems = computed(
  () => keyItemsList.value.map(({ payload }) => payload) || []
);

function populateList(listData: PayloadType[]) {
  const newList: KeyItem[] = [];
  // Make sure to preserve the keys associated with the objects, whether autogenerated or supplied:
  listData.forEach((item: PayloadType) => {
    const keyItem = props.listKey
      ? keyItemsList.value.find(
          ({ key }) => key === item[props.listKey as keyof PayloadType]
        )
      : keyItemsList.value.find(({ payload }) => item === payload);
    if (keyItem) newList.push({ ...keyItem, payload: item });
    else
      newList.push({
        key:
          props.listKey && Object.keys(item).includes(props.listKey)
            ? item[props.listKey as keyof PayloadType]
            : Symbol(),
        payload: item,
      });
  });
  keyItemsList.value = newList;
}

watch(() => props.list, populateList, { deep: true });

const emit = defineEmits<{
  (e: "liftItem", item: MovingItem<PayloadType>): void;
  (e: "dropItem", item: MovingItem<PayloadType>): void;
  (e: "hoverOverItem", item: MovingItem<PayloadType>): void;
}>();

/**
 * triggered when the mouse cursor enters a list item while dragging something.
 * @param index: index of the item hovered over.
 */
const hoverOverItem = (target: HTMLElement, index: number) => {
  enterList();
  if (
    !movingItem.value ||
    movingItem.value?.destination?.identifier !== props.identifier ||
    isMoving(arrangedItems.value[index])
  ) {
    return;
  }
  emit("hoverOverItem", toRaw(movingItem.value));
  movingItem.value.destination.index = index;

  // if the dragging item does not appear in the list, add it
  if (!arrangedItems.value?.includes(movingItem.value.payload)) {
    keyItemsList.value.splice(index, 0, {
      payload: movingItem.value.payload,
      key: movingItem.value.key,
    });
  }
  // else move it
  else {
    const moverIndex = keyItemsList.value.findIndex(
      ({ payload }) => payload === movingItem.value?.payload
    );
    keyItemsList.value =
      moverIndex < index
        ? [
            ...keyItemsList.value.slice(0, moverIndex),
            ...keyItemsList.value.slice(moverIndex + 1, index + 1),
            keyItemsList.value[moverIndex],
            ...keyItemsList.value.slice(index + 1),
          ]
        : [
            ...keyItemsList.value.slice(0, index),
            keyItemsList.value[moverIndex],
            ...keyItemsList.value.slice(index, moverIndex),
            ...keyItemsList.value.slice(moverIndex + 1),
          ];
  }
};

const leaveList = () => {
  if (movingItem.value !== undefined) {
    // N.b. if the v-for list inside the transitiongroup has a ref with a ref() constant in the setup function,
    // leaving the list will go clunky. https://github.com/vuejs/core/issues/8173
    const itemIndex = arrangedItems.value.indexOf(movingItem.value.payload);
    if (itemIndex >= 0) {
      keyItemsList.value.splice(itemIndex, 1);
    }
    if (movingItem.value.destination?.identifier == props.identifier) {
      movingItem.value.destination = movingItem.value.origin;
    }
  }
};

const enterList = () => {
  if (
    movingItem.value &&
    (movingItem.value.dropTargets.includes(props.identifier) ||
      (props.group && movingItem.value.dropTargets.includes(props.group)))
  ) {
    movingItem.value.destination = {
      identifier: props.identifier,
      type: "list",
      listItems: arrangedItems.value,
      meta: props.meta,
    };
  }
};

let offsetX: number = 0;
let offsetY: number = 0;

const liftItem = (event: PointerEvent, { key, payload }: KeyItem) => {
  if (
    props.options?.handle &&
    (event.target as HTMLElement).attributes.getNamedItem("name")?.value !==
      (typeof props.options.handle === "string"
        ? props.options.handle
        : "handle")
  )
    return;
  originItemBoundingBox = (
    event.currentTarget as HTMLElement
  )?.getBoundingClientRect();

  offsetX = pointer.x.value - originItemBoundingBox.x;
  offsetY = pointer.y.value - originItemBoundingBox.y;
  const originIndex = arrangedItems.value.indexOf(payload);
  const origin: DropTarget<PayloadType> = {
    identifier: props.identifier,
    type: "list",
    listItems: arrangedItems.value,
    index: originIndex,
  };
  movingItem.value = {
    payload,
    hoverElement,
    origin: origin,
    destination: { ...origin, meta: props.meta },
    dropTargets: [props.targets ?? props.group ?? props.identifier].flat(),
    key,
  };
  emit("liftItem", toRaw(movingItem.value));
};

/**
 * Set coordinates of the snap-target element as CSS-variables to use in dynamic classes
 **/
const setLandingZone = () => {
  const landingZone =
    document
      .getElementById("arrangeable-list-target-element")
      ?.getBoundingClientRect() ?? originItemBoundingBox;
  if (!landingZone) return;
  for (const property of [
    "x",
    "y",
    "width",
    "height",
    "top",
    "right",
    "bottom",
    "left",
  ] as const) {
    hoverElement.value?.style.setProperty(
      `--landingzone-${property}`,
      landingZone[property] + "px"
    );
  }
};

/**
 * dropItem happens when an element from this ArrangedList is dropped somewhere.
 * This is NOT triggered when an element from another list is dropped onto this one.
 */
const dropItem = () => {
  if (
    movingItem.value === undefined ||
    movingItem.value.origin.identifier !== props.identifier
  )
    return;

  setLandingZone();

  emit("dropItem", toRaw(movingItem.value));

  // this is required for dynamic classes; no way around yet using standard vue transition classes which are fixed.
  props.options.dropClass
    ?.split(" ")
    .forEach(
      (className) => className && hoverElement.value?.classList.add(className)
    );

  // repopulation is needed in case the drop event did not trigger a props change
  // otherwise the dropped item disappears.
  populateList(props.list);
  nextTick(() => (movingItem.value = undefined));
};

const pointer = usePointer();
useEventListener(document, "pointerup", dropItem);

let originItemBoundingBox: DOMRect | undefined;

const beforeKey = Symbol();
const afterKey = Symbol();

const itemInTransit = ref<PayloadType | undefined>();

onMounted(() => {
  populateList(props.list);
  document.body.style.touchAction = "none";
});
</script>

<template>
  <PointerElement
    @pointer-leave="leaveList"
    @pointer-enter="enterList"
    name="ArrangeableList"
    ref="listElement"
  >
    <TransitionGroup v-bind="options.listTransition">
      <div :key="beforeKey">
        <slot name="before" :arrangedItems="arrangedItems" />
      </div>
      <PointerElement
        v-for="(item, index) in keyItemsList || []"
        :key="item.key"
        :id="
          isMoving(item.payload) ? 'arrangeable-list-target-element' : undefined
        "
        :class="
          isMoving(item.payload) || itemInTransit === item.payload
            ? options.pickedItemClass
            : options.unpickedItemClass
        "
        @pointerdown.left.prevent="liftItem($event, item)"
        @pointer-enter="(target) => hoverOverItem(target, index)"
      >
        <slot
          :item="item.payload as PayloadType"
          :arrangedItems="arrangedItems"
        />
      </PointerElement>
      <PointerElement
        :key="afterKey"
        @pointer-enter="(target) => hoverOverItem(target, keyItemsList.length)"
      >
        <slot name="after" :arrangedItems="arrangedItems" />
      </PointerElement>
    </TransitionGroup>
    <Transition
      ref="hoverElement"
      v-bind="options.hoverTransition"
      @before-enter="itemInTransit = movingItem?.payload"
      @after-leave="itemInTransit = undefined"
      :class="options.hoverClass"
      :style="{
        left: pointer.x.value - offsetX + 'px',
        top: pointer.y.value - offsetY + 'px',
      }"
      style="z-index: 100000000; position: absolute"
    >
      <div v-if="movingItem && movingItem.origin.identifier === identifier">
        <slot :item="movingItem.payload" />
      </div>
    </Transition>
  </PointerElement>
</template>
